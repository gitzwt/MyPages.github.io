<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 04 Nov 2016 22:25:17 +0800</pubDate>
    <lastBuildDate>Fri, 04 Nov 2016 22:25:17 +0800</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>养只爬虫当宠物（Node.js爬虫爬取58同城租房信息）</title>
        <description>&lt;p&gt;先上一个源代码吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/answershuto/Rental&quot;&gt;https://github.com/answershuto/Rental&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;欢迎指导交流。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;nodejs&quot;&gt;搭建Node.js环境及启动服务&lt;/h2&gt;

&lt;p&gt;安装node以及npm，用express模块启动服务，加入自己所需要的中间件即可，这个不是本文所要讨论的重点，可以参考网上的一些教程搭建环境。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;url&quot;&gt;获取导航页URL以及数据&lt;/h2&gt;

&lt;p&gt;打开58同城主页，我主要针对杭州的二手房进行了爬取分析，所以进入杭州租房。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://hz.58.com/chuzu/pn1/?key=%E6%9D%AD%E5%B7%9E%E7%A7%9F%E6%88%BF%E5%AD%90&amp;amp;cmcskey=%E7%A7%9F%E6%88%BF%E5%AD%90&amp;amp;final=1&amp;amp;PGTID=0d3090a7-0004-f43c-ee04-95c2ea3d031f&amp;amp;ClickID=6&quot;&gt;http://hz.58.com/chuzu/pn1/?key=%E6%9D%AD%E5%B7%9E%E7%A7%9F%E6%88%BF%E5%AD%90&amp;amp;cmcskey=%E7%A7%9F%E6%88%BF%E5%AD%90&amp;amp;final=1&amp;amp;PGTID=0d3090a7-0004-f43c-ee04-95c2ea3d031f&amp;amp;ClickID=6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以得到这一串URL，上下页查看后就不难发现，pn后面的数字就是页面的页码，？后面的是一些get请求带带参数。用一个函数即可通过页码得到正确的URL。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function getUrl(page = 1){
	return  &#39;http://hz.58.com/chuzu/pn&#39;+page+&#39;/?key=%E6%9D%AD%E5%B7%9E%E7%A7%9F%E6%88%BF%E5%AD%90&amp;amp;cmcskey=%E7%A7%9F%E6%88%BF%E5%AD%90&amp;amp;final=1&amp;amp;PGTID=0d3090a7-0004-f43c-ee04-95c2ea3d031f&amp;amp;ClickID=6&#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据上面的URL我们就可以访问到每一页的所有租房信息&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/58Crawler/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;cheeriodom&quot;&gt;用cheerio模块解析dom&lt;/h2&gt;

&lt;p&gt;安装cheerio模块，使用cheerio模块解析dom，然后就可以类似jquery一样访问dom了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var cheerio = require(&#39;cheerio&#39;);
let $ = cheerio.load(html);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;url-1&quot;&gt;获取每个租房信息的URL&lt;/h2&gt;

&lt;p&gt;打开开发者模式，osX（option + command + I），windows（ F12 ），然后就可以在elements中看到文档结构了。（这里以chrome为例）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/58Crawler/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看到对应的a标签，我们只需要提取出该url即可，及对应的href，就是它点击跳转的URL。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;a href=&quot;http://jump.jinpai.58.com/service?target=INKicKZPP1UEhIHuBQyP3HVk6MOpffA1WNsEqTYuc2Gxa8zCQdEBOnSPwy7LRseGN-7sgB3XvvZTQ9JsSXvXBXOVP5s7-iWzO-jZ_WBRroCl_ZiBHb5v6-MxytthrUmoPF7B-ffISZByBLAX8fznJUcUsuV6KVKc9zyglbYlX_Ws57NkdXRy7vg4euiIN6TsyENc8bJRhqs&amp;amp;amp;local=79&amp;amp;amp;pubid=4204776&amp;amp;amp;version=A&amp;amp;amp;psid=179352405193657452887456131&amp;amp;amp;entinfo=27800613387971_0&amp;amp;amp;apptype=0 &quot; target=&quot;_blank&quot; class=&quot;t&quot; onclick=&quot;clickLog(&#39;from=fcpc_zflist_gzcount&#39;);&quot;&amp;gt;[单间]支持月付 文一路梧桐公寓 耀江文萃苑 中豪晴元&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该a标签的class为t，用$(‘a.t’)即可得到所有的a标签的对象，得到的是一个数组，遍历取出href属性即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(let i = 0; i &amp;lt; $(&#39;a.t&#39;).length; i++){
	rentalObj.add($(&#39;a.t&#39;)[i].attribs.href)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到了这些URL，接下来就可以用这些URL访问具体的租房信息了，每个URL对应一个租房页面。&lt;/p&gt;

&lt;h2 id=&quot;url-2&quot;&gt;根据租房信息的URL访问相应页面，爬取数据&lt;/h2&gt;

&lt;p&gt;还是先进入页面打开开发者模式。&lt;/p&gt;

&lt;p&gt;这次我们需要解析房屋所在地信息，用来可视化显示。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/58Crawler/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&#39;td.house-xqxq-content a.ablue&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;加上父标签可以过滤出更有针对性的dom，此时过滤出的是小区名称、本月均价、所在商圈等信息的dom，我们现在只需要第一个dom里面的数据，所以访问数组的[0]即可。&lt;/p&gt;

&lt;p&gt;除此之外为还需要页面里面的一张展示房屋信息的一张图片，找到对应dom可以发现id为smainPic。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&#39;#smainPic&#39;)[&#39;0&#39;].attribs.src 这样访问即可得到图片的URL。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其他我们还可以用同样的方法获取很多相关数据，比如$(‘.house-price’).text()得到价格数据，$(‘span.tel-num.tel-font’).text()可以得到房东的联系方式。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;通过百度地图进行可视化展示&lt;/h2&gt;

&lt;p&gt;这里使用百度地图api
&lt;a href=&quot;http://lbsyun.baidu.com/index.php?title=jspopular&quot;&gt;http://lbsyun.baidu.com/index.php?title=jspopular&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var map = new BMap.Map(&quot;container&quot;);          // 创建地图实例  
map.centerAndZoom(&quot;杭州&quot;, 12);
var localSearch = new BMap.LocalSearch(map);
localSearch.setSearchCompleteCallback(function(searchResult){
	var poi = searchResult.getPoi(0);/*地理位置信息*/
})
ocalSearch.search(params[url].location);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取经纬度以后再掉用相应的api在地图上显示即可，显示后再做什么效果，可自行发挥想象了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;关于反爬虫&lt;/h2&gt;

&lt;p&gt;在爬取过程中发现58同城的反爬虫策略，快速访问会让你输入验证码来验证是人在操作而不是代码访问。只要是人可以正常访问并不影响用户正常体验的网站都有办法绕过反爬虫策略。&lt;/p&gt;

&lt;p&gt;先采用较慢的方式发送http请求访问，此外每隔一段时间最好停一下，然后再继续访问。除此之外用User-Agent字段伪装成浏览器。最保险的方法就是购买代理，让代理用不同的ip地址去访问网站，即可绕过反爬虫机制。&lt;/p&gt;

&lt;p&gt;具体做法可以参照相关反爬虫策略的文章。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;效果图&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/58Crawler/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/58Crawler/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/58Crawler/6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/58Crawler/7.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/58Crawler/8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 25 Oct 2016 22:23:00 +0800</pubDate>
        <link>/jekyll/update/2016/10/25/%E5%85%BB%E5%8F%AA%E7%88%AC%E8%99%AB%E5%BD%93%E5%AE%A0%E7%89%A9-Node.js%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%9658%E5%90%8C%E5%9F%8E%E7%A7%9F%E6%88%BF%E4%BF%A1%E6%81%AF.html</link>
        <guid isPermaLink="true">/jekyll/update/2016/10/25/%E5%85%BB%E5%8F%AA%E7%88%AC%E8%99%AB%E5%BD%93%E5%AE%A0%E7%89%A9-Node.js%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%9658%E5%90%8C%E5%9F%8E%E7%A7%9F%E6%88%BF%E4%BF%A1%E6%81%AF.html</guid>
        
        <category>Node.js、网络爬虫、百度地图</category>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>Node.js实现图片上传</title>
        <description>&lt;p&gt;今天在开发&lt;a href=&quot;https://github.com/answershuto/Note.git&quot;&gt;染陌云笔记&lt;/a&gt;要实现图片上传来修改头像，在网上找资料尝试了很多方法以后最后只有这种方法管用，记录一下。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;首先是后端对实现&lt;/h2&gt;

&lt;p&gt;使用了这些中间件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var app = express();

app.set(&#39;view engine&#39;,&#39;ejs&#39;);
app.use(express.static(__dirname+&#39;/../views&#39;));

app.use(bodyParser.json());

app.use(cookieParser());

app.use(session({
	resave: false,
	saveUninitialized: true,
	secret: &#39;CloudNte&#39;,
	name: &#39;RanMoCloudNote&#39;
}));

app.use(function(req,res,next){
	if (!req.session.user) {
		if (req.url === &#39;/note/login&#39; || req.url === &#39;/note/register&#39;) {
			next();/*请求为登陆或者注册则不需要校验session*/
		};
	}
	else if (req.session.user) {
		next();
	};
})

require(&#39;../app/routes/note.server.routes&#39;)(app);

app.use(function(req, res, next){
	res.status(404);
	try{
		return res.json(&#39;No Found!&#39;);
	}
	catch(e){
		console.error(&#39;404 set header after send.&#39;);
	}
})

app.use(function(err, req, res, next){
	if (!err) {
		return next();
	};

	res.status(500);
	try{
		return res.json(err.message || &quot;server err&quot;);
	}
	catch(e){
		console.error(&#39;500 set header after send.&#39;)
	}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;uploadIcon路由后进入该函数，用formidable模块来实现图片上传。uploadDir指定上传后图片保存位置，keepExtensions可以使得上传的文件保持原来的文件的扩展名.之后上传的文件就会在uploadDir指定的目录下，可以用fs模块对文件进行操作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var formidable = require(&quot;formidable&quot;);

uploadIcon: function(req, res, next){
	var form = new formidable.IncomingForm();
	form.encoding = &#39;utf-8&#39;;
	form.uploadDir = __dirname+&#39;/../../uploadFiles/&#39;;
	form.keepExtensions = true;
	form.maxFieldsSize = 2*1024*1024;/*限制图片大小最大为2M*/

	var fileType;
	form.parse(req, function(err,fields,files){
		switch(files.image.type){
			case &#39;image/jpeg&#39;:
				fileType = &#39;jpeg&#39;;
				break;
			case &#39;image/png&#39;:
				fileType = &#39;png&#39;;
				break;
			case &#39;image/jpg&#39;:
				fileType = &#39;jpg&#39;;
				break;
		}

		if (fileType === undefined) {/*上传的图片格式没有按照指定要求*/
			res.send(&#39;uploadIcon img type err&#39;);
		};

		Users.find({userName:req.session.user.userName}, null,{},function(err,result){
			var dst = __dirname+&#39;/../../views/userDatas/userIcon/&#39;+req.session.user.userName+&#39;.&#39;+fileType;
			fs.writeFileSync(dst, fs.readFileSync(files.image.path));
	
			/*将用户头像路径存储到数据库*/
			result[0].userImage = &#39;/userDatas/userIcon/&#39;+req.session.user.userName+&#39;.&#39;+fileType;
			result[0].save(function(err){
				if (err) {
					console.log(&#39;uploadIcon userImage err!&#39;);
					res.send(&#39;uploadIcon userImage err&#39;);
				};
			})

			fs.unlinkSync(files.image.path);/*删除缓存文件*/
			res.send(&#39;uploadIcon successed&#39;);
		})
	})
},
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-1&quot;&gt;接下来是前端的实现&lt;/h2&gt;

&lt;p&gt;前端用了react，这里主要关注form即可。
form中填写action、method等必要字段，特别是不能忘记encType=”multipart/form-data”，否则不会http请求不会带上文件，只会将文件名发送过去。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;div className=&quot;&quot;&amp;gt;
	&amp;lt;div className=&quot;ui-edit-icon-div&quot;&amp;gt;
		&amp;lt;img onClick={this.handleIconClick} className=&quot;img-responsive ui-edit-icon img-circle&quot; src={this.state.userInformation.userImage+&#39;?&#39;+Math.random() || &quot;../../image/defaultHeadPortrait.png&quot;}&amp;gt;&amp;lt;/img&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;div className=&quot;ui-edit-notes-div&quot;&amp;gt;
		&amp;lt;span&amp;gt;注：头像大小不得超过2M&amp;lt;/span&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;div className=&quot;ui-edit-notes-div&quot;&amp;gt;
		&amp;lt;span&amp;gt;支持&amp;lt;/span&amp;gt;
		&amp;lt;span className=&quot;ui-color-red&quot;&amp;gt;*jpg、jpeg、png&amp;lt;/span&amp;gt;
		&amp;lt;span&amp;gt;格式的图片上传&amp;lt;/span&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;form className=&quot;ui-display-none&quot; action=&quot;/note/uploadIcon&quot; method=&quot;post&quot; encType=&quot;multipart/form-data&quot; target=&quot;userImage&quot;&amp;gt;
		&amp;lt;input id=&quot;edit_file&quot; onChange={this.handleFileChange} type=&quot;file&quot; accept=&quot;image/*&quot; name=&quot;image&quot;&amp;gt;&amp;lt;/input&amp;gt;
		&amp;lt;input id=&quot;edit_upload&quot; type=&quot;submit&quot; value=&quot;上传头像&quot;&amp;gt;&amp;lt;/input&amp;gt;
	&amp;lt;/form&amp;gt;
	&amp;lt;iframe id=&quot;edit_iframe&quot; name=&quot;userImage&quot; className=&quot;ui-display-none&quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更详细的内容可以参考我的&lt;a href=&quot;https://github.com/answershuto&quot;&gt;Github&lt;/a&gt;中的&lt;a href=&quot;https://github.com/answershuto/Note&quot;&gt;Note工程&lt;/a&gt;。&lt;/p&gt;

</description>
        <pubDate>Sun, 28 Aug 2016 22:08:00 +0800</pubDate>
        <link>/jekyll/update/2016/08/28/nodejs%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0.html</link>
        <guid isPermaLink="true">/jekyll/update/2016/08/28/nodejs%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0.html</guid>
        
        <category>前端</category>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>img、css等客户端缓存问题解决方案</title>
        <description>&lt;p&gt;今天在开发&lt;a href=&quot;https://github.com/answershuto/Note.git&quot;&gt;染陌云笔记&lt;/a&gt;的时候遇到了一个缓存问题，上传头像以后读取新的头像信息，因为我在后端做的处理是上传的新的头像以“用户名＋后缀”的方式保存，这样就导致每次上传后图片改变了，实际上图片等名字并没有改变。在没有刷新浏览器等情况下，即便切换页面刷新了当前页面等数据，图片也还是没有从服务器重新获取，依旧使用之前的图片。&lt;/p&gt;

&lt;p&gt;解决缓存的方案有两个：&lt;/p&gt;

&lt;p&gt;##1.使用版本控制&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=”text/javascript“ src=&quot;/js/test.js&quot;+&quot;?version:1.1.1&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##2.使用随机数保证每次刷新&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img src={this.state.userInformation.userImage+&#39;?&#39;+Math.random()}&amp;gt;&amp;lt;/img&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在我github的commit记录中可以看到相应修改&lt;a href=&quot;https://github.com/answershuto/Note.git&quot;&gt;https://github.com/answershuto/Note.git&lt;/a&gt;,Commits on Aug 28, 2016 , &lt;a href=&quot;https://github.com/answershuto/Note/commit/8b177522ae8592ecdac1a1c9fc9b568613b013b8&quot;&gt;commit记录&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 28 Aug 2016 21:19:00 +0800</pubDate>
        <link>/jekyll/update/2016/08/28/img-css%E7%AD%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</link>
        <guid isPermaLink="true">/jekyll/update/2016/08/28/img-css%E7%AD%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</guid>
        
        <category>前端</category>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>用safari对移动设备进行远程调试</title>
        <description>&lt;p&gt;因为在写一个基于移动设备陀螺仪功能的小游戏，所以遇到了这个移动设备调试的问题，在网上找到了用safari远程调试的方法，记录一下。&lt;/p&gt;

&lt;p&gt;工具：Mac iPhone&lt;/p&gt;

&lt;p&gt;1.首先需要在iPhone上打开Safari的远程调试功能，进入“设置”-&amp;gt;“Safari”-&amp;gt;“高级选项”中开启Web检查器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/Safari/iphone.PNG&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.打开Safari开启需要调试的网页。&lt;/p&gt;

&lt;p&gt;3.用数据线连接Mac，打开Mac上的Safari，如果没有开启开发者选项的话需要先开启开发者选项（点击Safari的偏好设置-&amp;gt;高级-&amp;gt;勾选“在菜单栏中显示“开发”菜单”，这样开发菜单就会出现了）。然后在开发菜单中选择刚才的iPhone设备（这里应该是显示的是别名）。接着就可以用Web检查器愉快地调试了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/Safari/kaifa.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/Safari/tiaoshi.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 17 Jun 2016 23:40:00 +0800</pubDate>
        <link>/jekyll/update/2016/06/17/%E7%94%A8safari%E5%AF%B9%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95.html</link>
        <guid isPermaLink="true">/jekyll/update/2016/06/17/%E7%94%A8safari%E5%AF%B9%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95.html</guid>
        
        <category>远程调试</category>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>用canvas＋jquery实现贪吃蛇游戏</title>
        <description>&lt;p&gt;最近学习了一下canvas的简单应用，就突然萌生了用canvas加jquery来写一个简单的贪吃蛇游戏的念头。写得比较随意并且匆忙，下班回来两个晚上做出来了，没有好好地设计整个工程以及模块之间的关系，之后也发现了好一些代码设计的问题，但是不影响功能，也最终懒得再去修改了。&lt;/p&gt;

&lt;p&gt;直接上源码吧，已上传至我的github，在Games工程下，后续可能还会写一点有意思的小游戏玩玩，统一放在这个工程下面。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/answershuto/Games&quot;&gt;https://github.com/answershuto/Games&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一开始在self = Page[‘RetroSnaker’]中加一些初始化以及调用snake等对象的方法写入，最后有一句self.init();从init函数开始掉用。&lt;/p&gt;

&lt;p&gt;随机数模块，产生随机数，用来产生随机的食物。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Random(n){
	return Math.floor(Math.random()*n+1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Dom是一个单例类，用来返回一些操作Dom的方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Dom(){
	return {
		renderNodeSnake: function(Node){
			context.fillStyle = &quot;red&quot;;
	        context.fillRect(Node.x * 10, Node.y * 5, 10, 5);
		},
		renderNodeGround: function(Node){
			context.strokeStyle = &quot;green&quot;;
	        context.fillStyle = &quot;white&quot;;
			context.fillRect(Node.x * 10, Node.y * 5, 10, 5);
			context.strokeRect(Node.x * 10, Node.y * 5, 10, 5);
		},
		renderFood: function(Node){
			context.fillStyle = &quot;blue&quot;;
	        context.fillRect(Node.x * 10, Node.y * 5, 10, 5);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Score是一个封装分数的类，add方法用来加分，attach用来注册回调函数，在加分后回调，会判断是否需要加速。get方法用来返回具体的得分。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Score(){
	this.score = 0;
}

Score.prototype.add = function(){
	this.score++;
	if (jQuery.type(this.func) == &#39;function&#39;) {
		this.func(this.score);
	};
}

Score.prototype.attach = function(func){
	this.func = func;
}

Score.prototype.get = function(){
	return this.score;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;food是一个封装食物的类，createFood方法掉用randomFood方法随机产生食物，在其中通过isSnakeBody判断使得新生成的食物不在蛇的身上。（第一次发布的时候就有小伙伴玩了告诉我说食物生成在蛇的身上了，然后蛇向前移动的时候渲染掉了那个食物，接着就没有食物可吃了），isBeEat用来判断是否被吃掉，被吃掉了就创造新的一个食物，同时加分。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function food(){
	this.food = {x:0,y:0};
	this.Score = new Score();
	this.Score.attach(self.SnakeObj.isAccelerate.bind(self.SnakeObj));
	this.createFood();
}

food.prototype.createFood = function(){
	this.food = this.randomFood();
	while (this.isSnakeBody(this.food)) {
		this.food = this.randomFood();
	};
	Dom().renderFood(this.food);
}

food.prototype.randomFood = function(){
	var food = {};
	food.x = Random(29);
	food.y = Random(29);

	return food; 
}

food.prototype.isSnakeBody = function(data){
	var bRet = false;
	$.each(self.SnakeObj.getBody(),function(index,item){
		if (data.x == item.x &amp;amp;&amp;amp; data.y == item.y) {
			bRet = true;
		};
	}.bind(this))

	return bRet;
}

food.prototype.isBeEat = function(data){
	if (data.x == this.food.x &amp;amp;&amp;amp; data.y == this.food.y) {
		this.beLonger = true;
		this.Score.add();
		this.createFood();
	};
}

food.prototype.isLonger = function(data){
	if (this.beLonger) {
		this.beLonger = false;
		return true;
	}
	else{
		return false;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;SnakeBody是一个封装蛇的身体的类，提供pop、push、unshift的方法修改蛇目前的长度以及未知，比如往前移动类一格，就需要pop一个尾部的节点，同时unshift一个头部的节点。用attach方法可以注册自定义事件的回调函数，自定义事件的种类用操作的方法的名称来表示，如“unshift”等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function SnakeBody(){
	this.functions = {};
	this.body = [];
}

SnakeBody.prototype.attach = function(type,func){
	this.functions[type] = func;
}

SnakeBody.prototype.unshift = function(data){
	if (jQuery.type(this.functions[&#39;unshift&#39;]) == &quot;function&quot;) {
		this.functions[&#39;unshift&#39;](data);
	};
	Dom().renderNodeSnake(data);
	
	return this.body.unshift(data);
}

SnakeBody.prototype.pop = function(){
	var data = this.body.pop();

	if (jQuery.type(this.functions[&#39;pop&#39;]) == &quot;function&quot;) {
		if (this.functions[&#39;pop&#39;](data)) {
			this.body.push(data);
		}
		else{
			Dom().renderNodeGround(data);
		}
	};

	return data;
}

SnakeBody.prototype.getBody = function(){
	return this.body;
}

SnakeBody.prototype.push = function(){
	if (jQuery.type(this.functions[&#39;push&#39;]) == &quot;function&quot;) {
		this.functions[&#39;push&#39;](arguments);
	};

	$.each(arguments, function(index,item){
		this.body.push(item);
	}.bind(this));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Snake是一个封装蛇的类，设计的时候忘记使用单例类，但是并不影响整个功能。getBody函数可以返回蛇的整个身体的所有节点信息，是一个数组，里面包了许多对象，每个对象的x与y代表当前节点的坐标，如[{x:0,y,0}……]，render用来将蛇渲染到街面上，这里掉用了canvas的fillRect方法，使得整一块都填充红色。isAccelerate是一个用来作为回调函数的函数，入参有一个得分，根据当前得分判断是否需要加速，加速后会重启定时器。changeDirection用来改变蛇的运动方向。而start与stop函数分别开启与关闭定时器，两个连续掉用即重启定时器，分开掉用实现暂停继续的功能。move函数是被定时器掉用的，每到一段时间定时器会掉用这个函数使蛇前进。isOver函数用来判断行进中的蛇是否撞倒墙壁或者撞倒自己。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Snake(){
	this.body = new SnakeBody();
	this.speed = 1;
	this.direction = &#39;left&#39;;
	this.nextDirection = &#39;left&#39;;
}

Snake.prototype.init = function(){
	this.body = new SnakeBody();
	this.food = new food();
	this.body.push({x:13,y:15},{x:14,y:15},{x:15,y:15},{x:16,y:15},{x:17,y:15});
	this.speed = 1;
	this.direction = &#39;left&#39;;
	this.nextDirection = &#39;left&#39;;
	clearInterval(this.timer);
	this.body.attach(&#39;unshift&#39;,this.food.isBeEat.bind(this.food));
	this.body.attach(&#39;pop&#39;,this.food.isLonger.bind(this.food));
	this.render();
}

Snake.prototype.getBody = function(){
	return this.body.getBody();
}

Snake.prototype.render = function(){
	context.fillStyle = &quot;red&quot;;
    $.each(this.body.getBody(),function(index,item){
    	context.fillRect(item.x * 10, item.y * 5, 10, 5);
    })
}

Snake.prototype.length = function(){
	return this.body.getBody().length;
}

Snake.prototype.isAccelerate = function(score){
	if (parseInt(score/3+1) != this.speed) {
		this.speed = parseInt(score/3+1);

		this.stop();
		this.start();
	};
}

Snake.prototype.changeDirection = function(direction){
	if (this.direction == &#39;up&#39; &amp;amp;&amp;amp; direction == &#39;down&#39;
	|| this.direction == &#39;down&#39; &amp;amp;&amp;amp; direction == &#39;up&#39;
	|| this.direction == &#39;left&#39; &amp;amp;&amp;amp; direction == &#39;right&#39;
	|| this.direction == &#39;right&#39; &amp;amp;&amp;amp; direction == &#39;left&#39;) {
		return;
	};

	this.nextDirection = direction;
}

Snake.prototype.start = function(){
	this.timer = setInterval(this.move.bind(this),1000/this.speed);
}

Snake.prototype.stop = function(){
	clearInterval(this.timer);
}

Snake.prototype.move = function(){
	this.direction = this.nextDirection;
	var newNode = {};
	newNode.x = this.body.getBody()[0].x;
	newNode.y = this.body.getBody()[0].y;
	if (this.direction == &#39;up&#39;) {
		newNode.y -= 1;
	}
	else if (this.direction == &#39;down&#39;) {
		newNode.y += 1;
	}
	else if (this.direction == &#39;left&#39;) {
		newNode.x -= 1;
	}
	else if (this.direction == &#39;right&#39;) {
		newNode.x += 1;
	}
	
	/*判断是否游戏结束*/
	if (this.isOver(newNode)) {
		alert(&#39;游戏结束！\n您的得分:&#39;+(this.length()-5));
		self.doms.RetroSnakerBeginAndStop.attr(&#39;disabled&#39;,true);
		this.stop();
		return;
	};

	
	this.body.unshift(newNode);
	this.body.pop();


}

Snake.prototype.isOver = function(newNode){
	if (newNode.x &amp;gt;= 30 || newNode.x &amp;lt; 0 || newNode.y &amp;gt;= 30 || newNode.y &amp;lt; 0) {
		/*撞到墙壁*/
		return true;
	}
	else{
		var bret = false;
		/*遍历节点是否撞到自己*/
		$.each(this.body.getBody(),function(index,item){
			if (newNode.x == item.x &amp;amp;&amp;amp; newNode.y == item.y) {
				bret = true;
			};
		})

		return bret;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 05 Jun 2016 19:21:00 +0800</pubDate>
        <link>/jekyll/update/2016/06/05/%E7%94%A8canvas-jquery%E5%AE%9E%E7%8E%B0%E8%B4%AA%E5%90%83%E8%9B%87%E6%B8%B8%E6%88%8F.html</link>
        <guid isPermaLink="true">/jekyll/update/2016/06/05/%E7%94%A8canvas-jquery%E5%AE%9E%E7%8E%B0%E8%B4%AA%E5%90%83%E8%9B%87%E6%B8%B8%E6%88%8F.html</guid>
        
        <category>HTML5 canvas jquery bootsrap</category>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>我的第一个nodeJS程序</title>
        <description>&lt;p&gt;最近开始学习nodeJS，简单学习了一下之后开始搭建自己的第一个nodeJS程序，把整个流程梳理了一下。&lt;/p&gt;

&lt;p&gt;首先编写package.json，或者用npm init 命令初始化&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$npm init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;生成的pachage.json如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;news project&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1.0.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;nodejs Project module&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;main&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;bin/www&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;keywords&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;author&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;license&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ISC&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;dependencies&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;body-parser&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^1.15.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;express&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^4.13.4&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用命令npm install来安装node所需的各个模块&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如下是我的代码的目录结构&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/first_nodeJS/mulu.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;文件结构&lt;/h3&gt;

&lt;p&gt;/app下面有三个文件夹，分别是controllers、models以及routes。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;controllers提供了控制器，将各种业务对数据库的直接操作进行了封装。命名规范：function.controllers.server.js。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;models中初始化各个模块。命名规范：function.model.server.js。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;routes则在里面添加不同的路由，可以使代码更加清晰。命名规范：function.routes.server.js。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;/bin下面的www文件是node程序的入口文件。&lt;/p&gt;

&lt;p&gt;/config下面的env存放各种配置，其他的文件如(express.js、mongoose.js)提供了express等功能等接口，并进行初始化。&lt;/p&gt;

&lt;p&gt;/node_modules存放了npm install下载的各个模块。&lt;/p&gt;

&lt;p&gt;/app.js由www调用，初始化各个config中的功能模块。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;每个模块通过module.exports给调用方提供接口，或者调用方可以直接require执行模块中的代码。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;介绍一下整个流程。&lt;/h3&gt;

&lt;p&gt;前端发过来的请求，根据路由会在news.server.routes.js中做判断，app.route方法为后端代码添加支持不同的路由，根据不同路有掉用不同Controller代码进行数据库操作，进行数据的增删改查，然后将得到的信息或者结果通过res参数返回。整个http请求也就完成了。&lt;/p&gt;

&lt;p&gt;我在路由代码中加入了‘／’的判断，在为根目录时返回index.html页面。调用require(‘fs’).readFile读取html文件并将它写入到res中。一开始用require(‘fs’).readFile直接将路径写成了’../../index.html’，后来才发现它的路径是根据程序运行的路径而不是当前文件的路径，用__dirname的到当前文件路径即可。&lt;/p&gt;

&lt;p&gt;更新：后来改为了用ejs来渲染前端页面。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;filenewsprojectzip&quot;&gt;最后附上源代码&lt;a href=&quot;/file/newsProject.zip&quot;&gt;点击下载&lt;/a&gt;&lt;/h3&gt;

</description>
        <pubDate>Sun, 15 May 2016 20:37:00 +0800</pubDate>
        <link>/jekyll/update/2016/05/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAnodeJS%E7%A8%8B%E5%BA%8F.html</link>
        <guid isPermaLink="true">/jekyll/update/2016/05/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAnodeJS%E7%A8%8B%E5%BA%8F.html</guid>
        
        <category>nodeJS</category>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>在mac下安装MongoDB</title>
        <description>&lt;p&gt;本文主要记录我在mac上搭建MongoDB数据库环境的过程.&lt;/p&gt;

&lt;p&gt;1.首先执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ brew update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个更新可能需要花一些时间，具体看多久没更新了。&lt;/p&gt;

&lt;p&gt;2.接着执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ brew install mongodb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装MongoDB，显示如下打印，这个速度比较快的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	==&amp;gt; Downloading https://homebrew.bintray.com/bottles/mongodb-3.2.6.el_capitan.bo Already downloaded: /Library/Caches/Homebrew/mongodb-3.2.6.el_capitan.bottle.tar.gz
	==&amp;gt; Pouring mongodb-3.2.6.el_capitan.bottle.tar.gz
	==&amp;gt; Caveats
	To have launchd start mongodb now and restart at login:
	  brew services start mongodb
	Or, if you don&#39;t want/need a background service you can just run:
	  mongod --config /usr/local/etc/mongod.conf
	==&amp;gt; Summary
	🍺  /usr/local/Cellar/mongodb/3.2.6: 17 files, 263.8M
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.如果要卸载MongoDB的话执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ brew uninstall mongodb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打印&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	Uninstalling /usr/local/Cellar/mongodb/3.2.6... (17 files, 263.8M)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.接着执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ mongod --config /usr/local/etc/mongod.conf 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这句话是根据/usr/local/etc/mongod.conf来对MongoDB进行配置,这个我一开始执行的时候一直很慢卡在这一步了，但是把终端关闭然后重新打开以后发现一下子就执行好了。&lt;/p&gt;

&lt;p&gt;5.接着就可以运行MongoDB了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ mongo
	MongoDB shell version: 3.2.6
	connecting to: test
	Server has startup warnings: 
	2016-05-08T22:04:58.899+0800 I CONTROL  [initandlisten] 
	2016-05-08T22:04:58.900+0800 I CONTROL  [initandlisten] ** WARNING: soft rlimits too low. Number of files is 256, should be at least 1000
	&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 08 May 2016 22:11:00 +0800</pubDate>
        <link>/jekyll/update/2016/05/08/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB.html</link>
        <guid isPermaLink="true">/jekyll/update/2016/05/08/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB.html</guid>
        
        <category>搭建环境</category>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>在mac下安装Redis</title>
        <description>&lt;p&gt;首先要从官网&lt;a href=&quot;http://www.redis.io&quot;&gt;http://www.redis.io&lt;/a&gt;上下载所需要版本（或者最新）的redis版本&lt;/p&gt;

&lt;p&gt;我下载了3.0.7版本,
&lt;a href=&quot;hhttp://download.redis.io/releases/redis-3.0.7.tar.gz&quot;&gt;http://download.redis.io/releases/redis-3.0.7.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后把文件解压，osX下双击或者命令行都可以。&lt;/p&gt;

&lt;p&gt;进入目录redis-3.0.7，一般是redis-后面跟版本号&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$cd redis-3.0.7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用make进行程序的编译安装&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$make&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;运行即可启动redis服务&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$src/redis-server&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;或者&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;$cd src&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;$./redis-server&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 04 May 2016 21:53:00 +0800</pubDate>
        <link>/jekyll/update/2016/05/04/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Redis.html</link>
        <guid isPermaLink="true">/jekyll/update/2016/05/04/%E5%9C%A8mac%E4%B8%8B%E5%AE%89%E8%A3%85Redis.html</guid>
        
        <category>搭建环境</category>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>git常用命令</title>
        <description>&lt;h2 id=&quot;markgit&quot;&gt;mark一些常用的git命令&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于最近开始玩Github了，所以在这里记录一下经常用到的git命令，主要为了自己方便查找也希望可以为阅读本文的人带来一点点便利，如有误欢迎指正。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;更详细可以参考《Git版本控制管理》，这是一本好书，不过里面的很多目前我还用不到。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table border=&quot;1&quot;&gt;
	&lt;tr&gt;
	  &lt;td&gt;git remote add upstream https://github.com/xxxxxx/xxxxxx.git&lt;/td&gt;
	  &lt;td&gt;新建分支并存放别人的repository&lt;/td&gt;
	&lt;/tr&gt;   
	&lt;tr&gt;
	  &lt;td&gt;git clone https://github.com/answershuto/answershuto.github.io&lt;/td&gt;
	  &lt;td&gt;克隆到本地&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git status&lt;/td&gt;
	  &lt;td&gt;查看状态&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git log&lt;/td&gt;
	  &lt;td&gt;查看git提交日志&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git add .&lt;/td&gt;
	  &lt;td&gt;添加所有本地文件&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git add filename&lt;/td&gt;
	  &lt;td&gt;添加某一个文件&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git remove  fileName&lt;/td&gt;
	  &lt;td&gt;删除文件&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git push&lt;/td&gt;
	  &lt;td&gt;提交到服务器上&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git pull origin master&lt;/td&gt;
	  &lt;td&gt;从服务器上拉取信息&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git branch -a&lt;/td&gt;
	  &lt;td&gt;查看所有分支&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git branch -r &lt;/td&gt;
	  &lt;td&gt;查看所有远程分支&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git branch -d XXX&lt;/td&gt;
	  &lt;td&gt;删除分支&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git branch XXX&lt;/td&gt;
	  &lt;td&gt;新建分支&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
	  &lt;td&gt;git checkout XXX&lt;/td&gt;
	  &lt;td&gt;切换分支&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;

</description>
        <pubDate>Sat, 23 Apr 2016 23:32:00 +0800</pubDate>
        <link>/jekyll/update/2016/04/23/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</link>
        <guid isPermaLink="true">/jekyll/update/2016/04/23/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</guid>
        
        <category>git</category>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>我对javascript继承的理解</title>
        <description>&lt;p&gt;记录一下学习js继承的学习心得，有误之处欢迎指正。&lt;/p&gt;

&lt;p&gt;javascript中的继承主要通过原型链的方式来实现，简单地说也就是对象a所指向的原型A是原型B的一个实例b，即B的实例是a所指向的原型。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;借用构造函数&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/jsInherit/parasiticCombination.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;这种继承方式的弊端显而易见，数据以及方法都必须定义在基类的构造函数中，在派生类中用call改变执行环境时，基类的数据以及方法会生成在派生类中，即this。但是如果在基类的原型中定义的方法以及数据，就无法在派生类中得到继承。将所有的方法以及数据都定义在构造函数中，也就没有什么封装可言了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原型式继承&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/jsInherit/prototype.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;原型继承主要通过Object.create()方法，构建一个新的派生类对象并使其原型指向基类。其函数内容可以描述为&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function object(o){
	function F();
	F.prototype = 0;
	return F;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;这种方法使得基类中的引用变量得到了共用，可以使得对象保持相似。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;组合继承&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;js里面最常用的继承方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;上代码：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/jsInherit/combination.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在派生类中调用基类的构造函数，如果不那么做会导致所有基类的成员及方法都属于原型，那么这些成员和方法都是“公有”的，也就是所有的派生类都指向同一块内存（这里就是原型），导致某一个派生类对象修改了基类中的成员数据会导致所有派生类的数据都改变。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;针对上述这个问题，在派生类中用call来执行基类的构造函数，使得基类的执行环境处于派生类，即this的指向改变。这样可以有效地防止出现由于基类对象作为原型导致基类对象中的引用对象产生的派生类实例所有引用对象都指向同一个对象的问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;组合式继承也有自己的弊端，在创建基类实例以及在派生类的构造函数中会两次调用基类的构造函数，第二次会覆盖第一次掉用时创建的对象及方法。&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在派生类的构造函数中初始化派生实例自己的成员&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;寄生式继承&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/jsInherit/parasitic.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;寄生式继承相当于克隆了基类对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;寄生组合式继承&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/jsInherit/parasiticCombination.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;由于组合式继承会在创建时两次掉用基类的构造函数构造基类的对象，所以综合寄生式继承，产生了寄生组合式继承。&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Wed, 20 Apr 2016 22:31:00 +0800</pubDate>
        <link>/jekyll/update/2016/04/20/%E6%88%91%E5%AF%B9javascript%E7%BB%A7%E6%89%BF%E7%9A%84%E7%90%86%E8%A7%A3.html</link>
        <guid isPermaLink="true">/jekyll/update/2016/04/20/%E6%88%91%E5%AF%B9javascript%E7%BB%A7%E6%89%BF%E7%9A%84%E7%90%86%E8%A7%A3.html</guid>
        
        <category>javascript</category>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
